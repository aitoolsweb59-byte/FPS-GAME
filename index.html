<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Lone Wolf - 1v1 Desert Eagle</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; user-select:none; }
  body { background:#000; overflow:hidden; width:100vw; height:100vh; font-family:'Segoe UI',sans-serif; }
  #gameCanvas { display:block; width:100vw; height:100vh; }

  /* HUD */
  #hud { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10; }

  /* Health bars */
  #playerHealth { position:absolute; bottom:140px; left:50%; transform:translateX(-50%); width:220px; }
  #enemyHealthBar { position:absolute; top:16px; left:50%; transform:translateX(-50%); width:200px; }
  .hbar-label { color:#fff; font-size:11px; font-weight:700; letter-spacing:1px; text-shadow:0 1px 3px #000; margin-bottom:3px; text-align:center; }
  .hbar-wrap { background:rgba(0,0,0,0.5); border-radius:6px; height:14px; border:1px solid rgba(255,255,255,0.2); overflow:hidden; }
  .hbar-fill { height:100%; border-radius:5px; transition:width 0.2s; }
  #phFill { background:linear-gradient(90deg,#22c55e,#4ade80); width:100%; }
  #ehFill { background:linear-gradient(90deg,#ef4444,#f87171); width:100%; }

  /* Ammo */
  #ammoDisp { position:absolute; bottom:155px; right:14px; color:#fff; font-size:22px; font-weight:900; text-shadow:0 0 8px #f59e0b,0 2px 4px #000; letter-spacing:2px; }
  #ammoLabel { font-size:10px; font-weight:600; color:#f59e0b; text-align:right; letter-spacing:1px; }

  /* Round info */
  #roundInfo { position:absolute; top:16px; left:14px; color:#fff; }
  #roundNum { font-size:13px; font-weight:900; letter-spacing:2px; text-shadow:0 1px 4px #000; }
  #scoreDisp { font-size:11px; color:#f59e0b; font-weight:700; margin-top:2px; }

  /* Crosshair */
  #crosshair { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:28px; height:28px; }
  #crosshair::before,#crosshair::after { content:''; position:absolute; background:rgba(255,255,255,0.85); border-radius:2px; }
  #crosshair::before { width:2px; height:100%; left:50%; transform:translateX(-50%); }
  #crosshair::after { height:2px; width:100%; top:50%; transform:translateY(-50%); }
  .ch-dot { position:absolute; width:4px; height:4px; background:#f59e0b; border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); }

  /* Hit marker */
  #hitMarker { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:40px; height:40px; opacity:0; transition:opacity 0.1s; pointer-events:none; }
  #hitMarker.show { opacity:1; }
  #hitMarker svg { width:100%; height:100%; }

  /* Kill feed */
  #killFeed { position:absolute; top:60px; right:10px; text-align:right; }
  .kf-item { font-size:11px; color:#fff; background:rgba(0,0,0,0.5); padding:2px 8px; border-radius:4px; margin-bottom:3px; animation:fadeKF 2s forwards; }
  @keyframes fadeKF { 0%{opacity:1} 70%{opacity:1} 100%{opacity:0} }

  /* Status text */
  #statusText { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; opacity:0; transition:opacity 0.3s; pointer-events:none; }
  #statusText.show { opacity:1; }
  #statusMain { font-size:38px; font-weight:900; letter-spacing:3px; text-shadow:0 0 20px currentColor; }
  #statusSub { font-size:14px; color:rgba(255,255,255,0.8); margin-top:6px; }

  /* Sprint indicator */
  #sprintBar { position:absolute; bottom:138px; left:50%; transform:translateX(-50%); width:120px; height:4px; background:rgba(255,255,255,0.15); border-radius:2px; }
  #sprintFill { height:100%; background:#f59e0b; border-radius:2px; width:100%; transition:width 0.1s; }

  /* Controls */
  #controls { position:fixed; bottom:0; left:0; width:100%; height:200px; z-index:20; pointer-events:none; }

  /* Joystick */
  #joystickZone { position:absolute; bottom:10px; left:10px; width:130px; height:130px; pointer-events:all; }
  #joystickBase { position:absolute; bottom:0; left:0; width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.25); }
  #joystickThumb { position:absolute; width:48px; height:48px; background:radial-gradient(circle,rgba(255,255,255,0.5),rgba(255,255,255,0.2)); border-radius:50%; border:2px solid rgba(255,255,255,0.5); top:50%; left:50%; transform:translate(-50%,-50%); transition:none; box-shadow:0 0 10px rgba(255,255,255,0.2); }

  /* Right buttons */
  #rightBtns { position:absolute; bottom:10px; right:10px; width:200px; height:180px; pointer-events:all; }
  .btn { position:absolute; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:11px; font-weight:800; letter-spacing:0.5px; color:#fff; text-shadow:0 1px 2px #000; cursor:pointer; border:2px solid rgba(255,255,255,0.3); active-scale:0.9; transition:transform 0.05s; }
  .btn:active { transform:scale(0.88); }

  #btnFire { width:70px; height:70px; background:radial-gradient(circle,rgba(239,68,68,0.7),rgba(185,28,28,0.5)); border-color:rgba(239,68,68,0.7); bottom:10px; right:5px; font-size:10px; box-shadow:0 0 15px rgba(239,68,68,0.3); }
  #btnAim  { width:56px; height:56px; background:radial-gradient(circle,rgba(251,191,36,0.6),rgba(180,83,9,0.4)); border-color:rgba(251,191,36,0.5); bottom:72px; right:65px; font-size:10px; }
  #btnJump { width:52px; height:52px; background:radial-gradient(circle,rgba(59,130,246,0.6),rgba(29,78,216,0.4)); border-color:rgba(59,130,246,0.5); bottom:80px; right:6px; font-size:10px; }
  #btnCrouch { width:48px; height:48px; background:radial-gradient(circle,rgba(139,92,246,0.6),rgba(91,33,182,0.4)); border-color:rgba(139,92,246,0.5); bottom:10px; right:82px; font-size:9px; }
  #btnSprint { width:44px; height:44px; background:radial-gradient(circle,rgba(34,197,94,0.6),rgba(21,128,61,0.4)); border-color:rgba(34,197,94,0.5); bottom:130px; right:10px; font-size:9px; }
  #btnReload { width:44px; height:44px; background:radial-gradient(circle,rgba(107,114,128,0.6),rgba(55,65,81,0.4)); border-color:rgba(107,114,128,0.5); bottom:135px; right:65px; font-size:9px; }

  /* Aim overlay */
  #aimOverlay { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:15; opacity:0; transition:opacity 0.15s; }
  #aimOverlay.active { opacity:1; }
  .aim-ring { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); border:2px solid rgba(255,200,0,0.6); border-radius:50%; }

  /* Screen flash */
  #flash { position:fixed; top:0;left:0;width:100%;height:100%; pointer-events:none; z-index:50; opacity:0; background:rgba(255,50,50,0.3); transition:opacity 0.08s; }
  #flash.show { opacity:1; }

  /* Start screen */
  #startScreen { position:fixed; top:0;left:0;width:100%;height:100%; z-index:100; display:flex; flex-direction:column; align-items:center; justify-content:center; background:linear-gradient(160deg,#0f172a,#1e293b,#0f172a); }
  .ss-logo { font-size:46px; font-weight:900; letter-spacing:4px; background:linear-gradient(90deg,#f59e0b,#ef4444,#f59e0b); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; text-shadow:none; }
  .ss-sub { color:rgba(255,255,255,0.5); font-size:13px; letter-spacing:3px; margin-top:4px; text-transform:uppercase; }
  .ss-card { background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:16px; padding:20px 28px; margin:24px 0; width:280px; }
  .ss-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; color:rgba(255,255,255,0.7); font-size:12px; }
  .ss-val { color:#f59e0b; font-weight:700; }
  .ss-btn { background:linear-gradient(90deg,#f59e0b,#ef4444); border:none; color:#fff; font-size:16px; font-weight:900; letter-spacing:3px; padding:16px 48px; border-radius:50px; cursor:pointer; box-shadow:0 4px 20px rgba(239,68,68,0.4); margin-top:8px; width:280px; }

  /* End screen */
  #endScreen { position:fixed; top:0;left:0;width:100%;height:100%; z-index:100; display:none; flex-direction:column; align-items:center; justify-content:center; background:rgba(0,0,0,0.9); }
  .es-result { font-size:52px; font-weight:900; letter-spacing:4px; }
  .es-score { font-size:28px; color:rgba(255,255,255,0.7); margin:12px 0; }
  .es-btn { background:linear-gradient(90deg,#f59e0b,#ef4444); border:none; color:#fff; font-size:14px; font-weight:900; letter-spacing:2px; padding:14px 40px; border-radius:50px; cursor:pointer; margin-top:20px; }

  /* Mobile camera pan zone */
  #camZone { position:fixed; top:0; right:0; width:60%; height:75%; z-index:19; pointer-events:all; }
</style>
</head>
<body>

<!-- Start Screen -->
<div id="startScreen">
  <div class="ss-logo">LONE WOLF</div>
  <div class="ss-sub">Desert Eagle Â· 1v1 Â· Multiplayer</div>
  <div class="ss-card">
    <div class="ss-row"><span>Your Name</span></div>
    <input id="nameInput" maxlength="12" placeholder="PLAYER" autocomplete="off" spellcheck="false"
      style="background:rgba(255,255,255,0.08);border:1px solid rgba(245,158,11,0.5);color:#f59e0b;
      font-size:18px;font-weight:900;letter-spacing:3px;text-transform:uppercase;text-align:center;
      width:100%;padding:10px 0;border-radius:8px;outline:none;font-family:'Segoe UI',sans-serif;margin-bottom:12px;"/>
    <div class="ss-row"><span>Room Code</span><span style="font-size:10px;color:#666">(leave empty = public)</span></div>
    <input id="roomInput" maxlength="6" placeholder="e.g. ABC123" autocomplete="off" spellcheck="false"
      style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);color:#fff;
      font-size:16px;font-weight:700;letter-spacing:4px;text-transform:uppercase;text-align:center;
      width:100%;padding:8px 0;border-radius:8px;outline:none;font-family:'Segoe UI',sans-serif;margin-bottom:4px;"/>
  </div>
  <div id="connStatus" style="font-size:11px;letter-spacing:2px;color:#666;margin-bottom:8px;">Connecting to serverâ€¦</div>
  <button class="ss-btn" id="playBtn" onclick="startGame()">â–¶  PLAY NOW</button>
  <div style="color:rgba(255,255,255,0.3);font-size:10px;letter-spacing:2px;margin-top:12px;">
    SHARE LINK WITH FRIEND â†’ SAME ROOM â†’ PLAY!
  </div>
</div>

<!-- End Screen -->
<div id="endScreen">
  <div class="es-result" id="esResult"></div>
  <div class="es-score" id="esScore"></div>
  <button class="es-btn" onclick="location.reload()">PLAY AGAIN</button>
</div>

<!-- Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- Camera zone -->
<div id="camZone"></div>

<!-- HUD -->
<div id="hud">
  <div id="roundInfo">
    <div id="roundNum">ROUND 1/5</div>
    <div id="scoreDisp">YOU 0 â€“ 0 BOT</div>
  </div>

  <div id="enemyHealthBar">
    <div class="hbar-label">âš” ENEMY</div>
    <div class="hbar-wrap"><div class="hbar-fill" id="ehFill"></div></div>
  </div>

  <div id="playerHealth">
    <div class="hbar-label">â¤ YOU</div>
    <div class="hbar-wrap"><div class="hbar-fill" id="phFill"></div></div>
  </div>

  <div id="ammoDisp">
    <div id="ammoNum">7/49</div>
    <div id="ammoLabel">DEAGLE</div>
  </div>

  <div id="sprintBar"><div id="sprintFill"></div></div>

  <div id="crosshair"><div class="ch-dot"></div></div>

  <div id="hitMarker">
    <svg viewBox="0 0 40 40">
      <line x1="8" y1="8" x2="14" y2="14" stroke="#f59e0b" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="32" y1="8" x2="26" y2="14" stroke="#f59e0b" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="8" y1="32" x2="14" y2="26" stroke="#f59e0b" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="32" y1="32" x2="26" y2="26" stroke="#f59e0b" stroke-width="2.5" stroke-linecap="round"/>
    </svg>
  </div>

  <div id="statusText">
    <div id="statusMain"></div>
    <div id="statusSub"></div>
  </div>

  <div id="killFeed"></div>
</div>

<!-- Aim Overlay -->
<div id="aimOverlay">
  <div class="aim-ring" style="width:160px;height:160px;"></div>
  <div class="aim-ring" style="width:80px;height:80px;opacity:0.5;"></div>
</div>

<!-- Controls -->
<div id="controls">
  <div id="joystickZone">
    <div id="joystickBase"></div>
    <div id="joystickThumb"></div>
  </div>
  <div id="rightBtns">
    <div class="btn" id="btnFire">ğŸ”¥<br>FIRE</div>
    <div class="btn" id="btnAim">ğŸ¯<br>AIM</div>
    <div class="btn" id="btnJump">â†‘<br>JUMP</div>
    <div class="btn" id="btnCrouch">â†“<br>CROUCH</div>
    <div class="btn" id="btnSprint">âš¡<br>SPRINT</div>
    <div class="btn" id="btnReload">â†º<br>RELOAD</div>
  </div>
</div>

<div id="flash"></div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  LONE WOLF â€” Free Fire style 1v1 Â· Desert Eagle Â· 5 Rounds
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let scene, camera, renderer, clock;
let player, enemy, bot;
let gameActive = false;

// â”€â”€ Game state
const GS = {
  round: 1, maxRounds: 5,
  playerScore: 0, botScore: 0,
  playerHP: 100, botHP: 100,
  maxHP: 100,
  ammo: 7, maxAmmo: 7, reserve: 49,
  reloading: false, reloadTimer: 0,
  isAiming: false, isSprinting: false, isCrouching: false,
  sprintStamina: 100,
  roundOver: false, gameOver: false,
  shotCooldown: 0
};

// â”€â”€ MULTIPLAYER STATE
const SERVER_URL = ''; // leave empty = same origin (Render)
let socket = null;
let myId = null;
let myName = 'PLAYER';
let opponentName = 'ENEMY';
let opponentMesh = null; // remote player's visible body
let opponentTarget = { x:0, y:0, z:0, ry:0 }; // interpolation target
let isConnected = false;
let isMultiplayer = false; // true when opponent is in room
let pingStart = 0, pingMs = 0;
let waitingForOpponent = true;

// Opponent colors
const OPP_COLOR = 0xef4444;

function initSocket() {
  try {
    socket = io(SERVER_URL, { transports:['websocket','polling'], reconnectionAttempts:10 });
  } catch(e) { updateConnStatus('offline'); return; }

  socket.on('connect', () => {
    isConnected = true;
    myId = socket.id;
    updateConnStatus('connected');
    setInterval(() => { pingStart=Date.now(); socket.emit('ping_fps'); }, 3000);
  });

  socket.on('disconnect', () => { isConnected=false; updateConnStatus('offline'); });

  socket.on('pong_fps', () => {
    pingMs = Date.now()-pingStart;
    const el=document.getElementById('pingLabel');
    if(el) el.textContent=pingMs+'ms';
  });

  socket.on('waitingForOpponent', () => {
    waitingForOpponent = true;
    updateConnStatus('waiting');
  });

  socket.on('matchReady', (data) => {
    waitingForOpponent = false;
    isMultiplayer = true;
    opponentName = data.opponentName || 'ENEMY';
    document.getElementById('enemyNameLabel') && (document.getElementById('enemyNameLabel').textContent = opponentName);
    updateConnStatus('matched');
    // Enable play button
    const btn = document.getElementById('playBtn');
    if(btn){ btn.disabled=false; btn.style.opacity='1'; btn.textContent='â–¶  PLAY NOW'; }
  });

  socket.on('opponentMoved', (data) => {
    opponentTarget = data;
    if(opponentMesh) {
      // show opponent
      opponentMesh.visible = true;
    }
    // Update online count
    const el=document.getElementById('onlineCount');
    if(el) el.textContent='2';
  });

  socket.on('opponentShot', (data) => {
    if(!isMultiplayer || GS.roundOver) return;
    // Check if hit lands (server-authoritative hit detection)
    if(data.hit){
      const dmg = data.headshot ? 85 : 24;
      dealDamageToPlayer(dmg);
      if(data.headshot) addKillFeed('ğŸ¯ HEADSHOT by '+opponentName+'! -'+dmg);
    }
  });

  socket.on('opponentHit', (data) => {
    if(!isMultiplayer) return;
    // Opponent confirmed we hit them
    showHitMarker(data.headshot);
    dealDamageToBot(data.dmg, data.headshot);
  });

  socket.on('roundResult', (data) => {
    if(!GS.roundOver) endRound(data.winner === myId ? 'player' : 'bot');
  });

  socket.on('opponentLeft', () => {
    isMultiplayer = false;
    waitingForOpponent = true;
    addKillFeed('âš ï¸ '+opponentName+' disconnected!');
    if(opponentMesh) opponentMesh.visible = false;
    document.getElementById('onlineCount') && (document.getElementById('onlineCount').textContent='1');
  });

  socket.on('opponentReloading', () => {
    addKillFeed('ğŸ”„ '+opponentName+' is reloading...');
  });
}

function updateConnStatus(s) {
  const el = document.getElementById('connStatus');
  if(!el) return;
  const msgs = {
    connected: 'ğŸŸ¢ Connected â€” waiting for opponentâ€¦',
    offline:   'ğŸ”´ Offline â€” multiplayer unavailable',
    waiting:   'ğŸŸ¡ Waiting for opponent to joinâ€¦',
    matched:   'ğŸŸ¢ Opponent found! You can play now.',
  };
  el.textContent = msgs[s] || s;
  el.style.color = s==='matched'?'#4ade80':s==='offline'?'#ef4444':'#f59e0b';
}

// Throttled position send
let lastPosSend = 0;
function sendPosition() {
  if(!isConnected || !gameActive) return;
  const now = Date.now();
  if(now - lastPosSend < 50) return;
  lastPosSend = now;
  socket.emit('fps_move', {
    x: player.position.x,
    y: player.position.y,
    z: player.position.z,
    ry: CAM.yaw,
    hp: GS.playerHP,
  });
}

function sendShot(hitType) {
  // hitType: null | 'body' | 'head'
  if(!isConnected) return;
  socket.emit('fps_shot', { hit: !!hitType, headshot: hitType==='head' });
}

// Build remote player mesh (opponent)
function buildOpponentMesh() {
  const g = new THREE.Group();
  const mat = c => new THREE.MeshLambertMaterial({color:c});
  // Body
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.8,0.35), mat(0x8c3a3a));
  torso.position.y=1.0; g.add(torso);
  // Head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.22,10,8), mat(0xd4aa88));
  head.position.y=1.65; g.add(head);
  // Helmet
  const helm = new THREE.Mesh(new THREE.SphereGeometry(0.24,10,8,0,Math.PI*2,0,Math.PI/2), mat(0x3a1a1a));
  helm.position.y=1.65; g.add(helm);
  // Arms
  const armL=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.09,0.7,6),mat(0x8c3a3a));
  armL.position.set(-0.4,0.95,0); armL.rotation.z=0.2; g.add(armL);
  const armR=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.09,0.7,6),mat(0x8c3a3a));
  armR.position.set(0.4,0.95,0); armR.rotation.z=-0.2; g.add(armR);
  // Legs
  const legL=new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.10,0.75,6),mat(0x3a2a2a));
  legL.position.set(-0.17,0.37,0); g.add(legL);
  const legR=new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.10,0.75,6),mat(0x3a2a2a));
  legR.position.set(0.17,0.37,0); g.add(legR);
  // Name tag
  const cv = document.createElement('canvas'); cv.width=256; cv.height=64;
  const ctx2 = cv.getContext('2d');
  ctx2.fillStyle='#ef4444'; ctx2.font='bold 28px Segoe UI';
  ctx2.textAlign='center'; ctx2.textBaseline='middle';
  ctx2.fillText(opponentName.toUpperCase().slice(0,12),128,32);
  const tex = new THREE.CanvasTexture(cv);
  const tag = new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false}));
  tag.scale.set(2,0.5,1); tag.position.y=2.2; g.add(tag);
  // Hitboxes (for raycasting)
  const headHB=new THREE.Mesh(new THREE.SphereGeometry(0.26,6,4),new THREE.MeshBasicMaterial({visible:false}));
  headHB.position.y=1.65; headHB.userData.isHead=true; g.add(headHB);
  const bodyHB=new THREE.Mesh(new THREE.BoxGeometry(0.65,0.95,0.45),new THREE.MeshBasicMaterial({visible:false}));
  bodyHB.position.y=1.0; bodyHB.userData.isBody=true; g.add(bodyHB);
  g.userData.headHB = headHB;
  g.userData.bodyHB = bodyHB;
  g.position.set(0,0,18);
  g.visible = false;
  scene.add(g);
  return g;
}

function interpolateOpponent(dt) {
  if(!opponentMesh || !opponentMesh.visible) return;
  const t = opponentTarget;
  opponentMesh.position.x += (t.x - opponentMesh.position.x) * Math.min(1, dt*14);
  opponentMesh.position.y += (t.y - opponentMesh.position.y) * Math.min(1, dt*14);
  opponentMesh.position.z += (t.z - opponentMesh.position.z) * Math.min(1, dt*14);
  if(t.ry !== undefined){
    let dy = t.ry - opponentMesh.rotation.y;
    while(dy>Math.PI) dy-=Math.PI*2; while(dy<-Math.PI) dy+=Math.PI*2;
    opponentMesh.rotation.y += dy * Math.min(1, dt*10);
  }
}

// â”€â”€ Player physics (initialized in startGame after Three.js loads)
let PL = null;

// â”€â”€ Joystick state
const JOY = { active:false, id:-1, cx:60, cy:60, dx:0, dy:0, baseX:0, baseY:0 };

// â”€â”€ Camera pan
const CAM = { active:false, id:-1, lastX:0, lastY:0, yaw:0, pitch:0 };

// â”€â”€ Input flags
const INPUT = { fire:false, aim:false, jump:false, crouch:false, sprint:false, reload:false };

// â”€â”€ Bot AI (initialized in startGame after Three.js loads)
let BOT = null;

// â”€â”€ Arena obstacles (AABB for collision)
const obstacles = [];

// â”€â”€ DOM refs
const DOM = {
  phFill: null, ehFill: null, ammoNum: null,
  roundNum: null, scoreDisp: null,
  statusText: null, statusMain: null, statusSub: null,
  hitMarker: null, flash: null,
  aimOverlay: null, crosshair: null,
  sprintFill: null, killFeed: null
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  myName = (document.getElementById('nameInput')?.value.trim() || 'PLAYER').toUpperCase().slice(0,12);
  const roomCode = (document.getElementById('roomInput')?.value.trim() || '').toUpperCase();
  document.getElementById('startScreen').style.display = 'none';
  PL = {
    vel: new THREE.Vector3(),
    onGround: true,
    height: 1.7, crouchHeight: 1.1,
    walkSpeed: 4.5, sprintSpeed: 8, crouchSpeed: 2,
    jumpForce: 6,
    gravity: -16
  };
  BOT = {
    vel: new THREE.Vector3(),
    onGround: true,
    roamTarget: new THREE.Vector3(),
    roamTimer: 0,
    shotTimer: 0,
    shotInterval: 2.5,
    seePlayer: false,
    hp: 100,
    turnSpeed: 1.2,
    wanderAngle: 0
  };
  initDOM();
  initThree();
  buildArena();
  buildPlayer();
  buildEnemy(); // bot (hidden if multiplayer)
  initControls();
  gameActive = true;
  clock = new THREE.Clock();
  // Init multiplayer
  opponentMesh = buildOpponentMesh();
  if(isConnected) {
    socket.emit('fps_join', { name: myName, room: roomCode });
    // If multiplayer opponent found, hide bot
    if(isMultiplayer) enemy.visible = false;
  }
  animate();
}

function initDOM() {
  for (const k of Object.keys(DOM)) DOM[k] = document.getElementById(k) || document.querySelector('#'+k) || null;
  DOM.phFill    = document.getElementById('phFill');
  DOM.ehFill    = document.getElementById('ehFill');
  DOM.ammoNum   = document.getElementById('ammoNum');
  DOM.roundNum  = document.getElementById('roundNum');
  DOM.scoreDisp = document.getElementById('scoreDisp');
  DOM.statusText = document.getElementById('statusText');
  DOM.statusMain = document.getElementById('statusMain');
  DOM.statusSub  = document.getElementById('statusSub');
  DOM.hitMarker  = document.getElementById('hitMarker');
  DOM.flash      = document.getElementById('flash');
  DOM.aimOverlay = document.getElementById('aimOverlay');
  DOM.crosshair  = document.getElementById('crosshair');
  DOM.sprintFill = document.getElementById('sprintFill');
  DOM.killFeed   = document.getElementById('killFeed');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  THREE.JS SETUP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initThree() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.FogExp2(0xb0c4de, 0.025);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
  camera.position.set(0, PL.height, 0);

  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: false, powerPreference:'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.shadowMap.enabled = false;

  // Lights
  const amb = new THREE.AmbientLight(0xffeedd, 0.7);
  scene.add(amb);
  const sun = new THREE.DirectionalLight(0xfff0dd, 1.0);
  sun.position.set(20, 40, 20);
  scene.add(sun);
  const fill = new THREE.DirectionalLight(0xaaddff, 0.3);
  fill.position.set(-20, 10, -20);
  scene.add(fill);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ARENA BUILDING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeMat(color, rough=0.8) {
  return new THREE.MeshLambertMaterial({ color });
}

function addBox(x,y,z, w,h,d, color, scene) {
  const geo = new THREE.BoxGeometry(w,h,d);
  const mat = makeMat(color);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y+h/2, z);
  scene.add(mesh);
  // AABB
  obstacles.push({
    minX: x-w/2, maxX: x+w/2,
    minY: y,     maxY: y+h,
    minZ: z-d/2, maxZ: z+d/2
  });
  return mesh;
}

function buildArena() {
  const GROUND_SIZE = 60;

  // Ground
  const gGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, 20, 20);
  const gMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
  const ground = new THREE.Mesh(gGeo, gMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Ground grid detail
  const gridGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
  const gridMat = new THREE.MeshLambertMaterial({ color: 0x7a6444, transparent:true, opacity:0.3, wireframe:true });
  const grid = new THREE.Mesh(gridGeo, gridMat);
  grid.rotation.x = -Math.PI/2;
  grid.position.y = 0.01;
  scene.add(grid);

  // Arena walls (invisible collision walls)
  const hs = GROUND_SIZE/2;
  [{x:0,z:-hs,w:GROUND_SIZE,d:1},{x:0,z:hs,w:GROUND_SIZE,d:1},{x:-hs,z:0,w:1,d:GROUND_SIZE},{x:hs,z:0,w:1,d:GROUND_SIZE}]
  .forEach(w => obstacles.push({ minX:w.x-w.w/2, maxX:w.x+w.w/2, minY:0, maxY:5, minZ:w.z-w.d/2, maxZ:w.z+w.d/2 }));

  // â”€â”€ Visible arena boundary walls
  const wallColor = 0x5a6e4a;
  const wallH = 3;
  function makeWall(x,z,w,d) {
    const g = new THREE.BoxGeometry(w,wallH,d);
    const m = new THREE.Mesh(g, makeMat(wallColor));
    m.position.set(x, wallH/2, z);
    scene.add(m);
  }
  makeWall(0, -hs, GROUND_SIZE, 1);
  makeWall(0,  hs, GROUND_SIZE, 1);
  makeWall(-hs, 0, 1, GROUND_SIZE);
  makeWall( hs, 0, 1, GROUND_SIZE);

  // Corner towers
  [[hs-0.5,-hs+0.5],[hs-0.5,hs-0.5],[-hs+0.5,-hs+0.5],[-hs+0.5,hs-0.5]].forEach(([x,z])=>{
    const g=new THREE.CylinderGeometry(1.2,1.4,wallH+1.5,8);
    const m=new THREE.Mesh(g,makeMat(0x4a5e3a));
    m.position.set(x,( wallH+1.5)/2,z);
    scene.add(m);
  });

  // â”€â”€ Center structure
  addBox(0,0,0, 4,2.5,4, 0x8b7355, scene);
  // Center top trim
  {const g=new THREE.BoxGeometry(4.5,0.3,4.5); const m=new THREE.Mesh(g,makeMat(0x6b5535)); m.position.set(0,2.65,0); scene.add(m);}

  // â”€â”€ Scattered barricades / cover
  const covers = [
    {x:8, z:5,  w:4, h:1.2, d:1, c:0x8b8b7a},
    {x:-8,z:-5, w:4, h:1.2, d:1, c:0x8b8b7a},
    {x:5, z:-8, w:1, h:1.2, d:4, c:0x7a8b8a},
    {x:-5,z:8,  w:1, h:1.2, d:4, c:0x7a8b8a},
    {x:12,z:0,  w:1.5,h:2,  d:1.5,c:0x6b6b5a},
    {x:-12,z:0, w:1.5,h:2,  d:1.5,c:0x6b6b5a},
    {x:0, z:12, w:1.5,h:2,  d:1.5,c:0x6b6b5a},
    {x:0, z:-12,w:1.5,h:2,  d:1.5,c:0x6b6b5a},
    // Rubble piles
    {x:15,z:10, w:2,h:0.8,d:2,c:0x7a7060},
    {x:-15,z:-10,w:2,h:0.8,d:2,c:0x7a7060},
    {x:10,z:-15, w:2,h:0.8,d:2,c:0x7a7060},
    {x:-10,z:15, w:2,h:0.8,d:2,c:0x7a7060},
    // Long walls
    {x:16,z:5,  w:6,h:1.8,d:0.8,c:0x8b7565},
    {x:-16,z:-5,w:6,h:1.8,d:0.8,c:0x8b7565},
    {x:5,z:16,  w:0.8,h:1.8,d:6,c:0x8b7565},
    {x:-5,z:-16,w:0.8,h:1.8,d:6,c:0x8b7565},
  ];
  covers.forEach(c => addBox(c.x,0,c.z,c.w,c.h,c.d,c.c,scene));

  // Decorative cylinders (pillars)
  [[7,-7],[-7,7],[7,7],[-7,-7]].forEach(([x,z])=>{
    const g=new THREE.CylinderGeometry(0.5,0.6,3,8);
    const m=new THREE.Mesh(g,makeMat(0x7a6a5a));
    m.position.set(x,1.5,z);
    scene.add(m);
    obstacles.push({minX:x-0.6,maxX:x+0.6,minY:0,maxY:3,minZ:z-0.6,maxZ:z+0.6});
  });

  // Ground patches (decal-style)
  [[4,3],[-6,-4],[10,8]].forEach(([x,z])=>{
    const g=new THREE.CircleGeometry(2.5+Math.random(),8);
    const m=new THREE.Mesh(g,makeMat(0x7a6a55));
    m.rotation.x=-Math.PI/2; m.position.set(x,0.02,z);
    scene.add(m);
  });

  // Sky backdrop
  const skyGeo = new THREE.SphereGeometry(90,12,8);
  const skyMat = new THREE.MeshBasicMaterial({ color:0x87CEEB, side:THREE.BackSide });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Distant trees
  for(let i=0;i<12;i++){
    const ang=Math.random()*Math.PI*2;
    const r=26+Math.random()*4;
    const x=Math.cos(ang)*r, z=Math.sin(ang)*r;
    const h=3+Math.random()*2;
    const trunk=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.2,h,6),makeMat(0x5c4a2a));
    trunk.position.set(x,h/2,z);
    scene.add(trunk);
    const top=new THREE.Mesh(new THREE.ConeGeometry(0.8+Math.random()*0.4,2+Math.random(),7),makeMat(0x2d6a30));
    top.position.set(x,h+0.8,z);
    scene.add(top);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PLAYER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildPlayer() {
  // Player is just the camera
  player = new THREE.Object3D();
  player.position.set(0, 0, -18);
  scene.add(player);
  player.add(camera);
  camera.position.set(0, PL.height, 0);

  // Gun model in view
  buildGunModel();
}

let gunMesh;
function buildGunModel() {
  const g = new THREE.Group();
  // Body
  const body=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.12,0.4),makeMat(0x222222));
  g.add(body);
  // Barrel
  const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.32,6),makeMat(0x333333));
  barrel.rotation.x=Math.PI/2; barrel.position.z=-0.32;
  g.add(barrel);
  // Grip
  const grip=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.16,0.08),makeMat(0x1a1a1a));
  grip.position.set(0,-0.13,0.05);
  g.add(grip);
  // Trigger guard
  const trig=new THREE.Mesh(new THREE.TorusGeometry(0.04,0.01,4,8,Math.PI),makeMat(0x111111));
  trig.position.set(0,-0.06,0.02); trig.rotation.x=-Math.PI/2;
  g.add(trig);
  // Sight
  const sight=new THREE.Mesh(new THREE.BoxGeometry(0.02,0.03,0.02),makeMat(0x444444));
  sight.position.set(0,0.07,-0.1);
  g.add(sight);

  g.position.set(0.18,-0.14,-0.3);
  camera.add(g);
  gunMesh = g;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ENEMY BOT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let enemyGroup, enemyHead, enemyBody, enemyHeadHB, enemyBodyHB;
function buildEnemy() {
  enemyGroup = new THREE.Group();
  enemyGroup.position.set(0, 0, 18);
  scene.add(enemyGroup);

  // â”€â”€ Body (torso)
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.8,0.35), makeMat(0x3a5a8c));
  torso.position.y = 1.0;
  enemyGroup.add(torso);

  // Chest stripe
  const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.62,0.1,0.36), makeMat(0x2a4a7c));
  stripe.position.y = 1.1;
  enemyGroup.add(stripe);

  // â”€â”€ Head
  const headG = new THREE.Mesh(new THREE.SphereGeometry(0.22,10,8), makeMat(0xd4aa88));
  headG.position.y = 1.65;
  enemyGroup.add(headG);

  // Helmet
  const helm = new THREE.Mesh(new THREE.SphereGeometry(0.24,10,8,0,Math.PI*2,0,Math.PI/2), makeMat(0x2a3a2a));
  helm.position.y = 1.65;
  enemyGroup.add(helm);

  // â”€â”€ Arms
  const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.09,0.7,6), makeMat(0x3a5a8c));
  armL.position.set(-0.4,0.95,0); armL.rotation.z=0.2;
  enemyGroup.add(armL);
  const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.09,0.7,6), makeMat(0x3a5a8c));
  armR.position.set(0.4,0.95,0); armR.rotation.z=-0.2;
  enemyGroup.add(armR);

  // â”€â”€ Legs
  const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.10,0.75,6), makeMat(0x2a2a4a));
  legL.position.set(-0.17,0.37,0);
  enemyGroup.add(legL);
  const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.10,0.75,6), makeMat(0x2a2a4a));
  legR.position.set(0.17,0.37,0);
  enemyGroup.add(legR);

  // â”€â”€ Bot gun
  const botGun = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.09,0.35), makeMat(0x111111));
  botGun.position.set(0.35,1.05,-0.2);
  enemyGroup.add(botGun);

  // â”€â”€ Hitbox helpers (invisible)
  enemyHeadHB = new THREE.Mesh(new THREE.SphereGeometry(0.26,6,4), new THREE.MeshBasicMaterial({visible:false}));
  enemyHeadHB.position.y = 1.65;
  enemyGroup.add(enemyHeadHB);

  enemyBodyHB = new THREE.Mesh(new THREE.BoxGeometry(0.65,0.95,0.45), new THREE.MeshBasicMaterial({visible:false}));
  enemyBodyHB.position.y = 1.0;
  enemyGroup.add(enemyBodyHB);

  // Store reference
  enemy = enemyGroup;
  resetBot();
}

function resetBot() {
  BOT.roamTimer = 0;
  BOT.shotTimer = 0;
  BOT.seePlayer = false;
  enemy.position.set(0, 0, 18);
  enemy.rotation.y = Math.PI;
  GS.botHP = GS.maxHP;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CONTROLS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initControls() {
  const jZone = document.getElementById('joystickZone');
  const jBase = document.getElementById('joystickBase');
  const jThumb = document.getElementById('joystickThumb');
  const camZone = document.getElementById('camZone');

  // Joystick touch
  jZone.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    const r = jZone.getBoundingClientRect();
    JOY.active = true; JOY.id = t.identifier;
    JOY.baseX = r.left + r.width/2;
    JOY.baseY = r.top + r.height/2;
    JOY.cx = r.width/2; JOY.cy = r.height/2;
  }, {passive:false});

  jZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === JOY.id) {
        const r = jZone.getBoundingClientRect();
        const dx = t.clientX - JOY.baseX;
        const dy = t.clientY - JOY.baseY;
        const maxR = 35;
        const len = Math.sqrt(dx*dx+dy*dy);
        const cx = len>maxR ? dx/len*maxR : dx;
        const cy = len>maxR ? dy/len*maxR : dy;
        JOY.dx = cx/maxR;
        JOY.dy = cy/maxR;
        jThumb.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
      }
    }
  }, {passive:false});

  const jEnd = e => {
    e.preventDefault();
    JOY.active = false; JOY.dx = 0; JOY.dy = 0;
    jThumb.style.transform = 'translate(-50%,-50%)';
  };
  jZone.addEventListener('touchend', jEnd, {passive:false});
  jZone.addEventListener('touchcancel', jEnd, {passive:false});

  // Camera pan zone
  camZone.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    CAM.active = true; CAM.id = t.identifier;
    CAM.lastX = t.clientX; CAM.lastY = t.clientY;
  }, {passive:false});

  camZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === CAM.id) {
        const sensitivity = GS.isAiming ? 0.12 : 0.22;
        CAM.yaw   -= (t.clientX - CAM.lastX) * sensitivity * 0.01 * (Math.PI);
        CAM.pitch -= (t.clientY - CAM.lastY) * sensitivity * 0.01 * (Math.PI);
        CAM.pitch  = Math.max(-Math.PI/3, Math.min(Math.PI/3, CAM.pitch));
        CAM.lastX  = t.clientX; CAM.lastY = t.clientY;
      }
    }
  }, {passive:false});

  const camEnd = e => { e.preventDefault(); CAM.active = false; };
  camZone.addEventListener('touchend', camEnd, {passive:false});
  camZone.addEventListener('touchcancel', camEnd, {passive:false});

  // Right buttons
  const firBtn = document.getElementById('btnFire');
  firBtn.addEventListener('touchstart', e=>{e.preventDefault(); INPUT.fire=true;},{passive:false});
  firBtn.addEventListener('touchend',   e=>{e.preventDefault(); INPUT.fire=false;},{passive:false});

  const aimBtn = document.getElementById('btnAim');
  aimBtn.addEventListener('touchstart', e=>{e.preventDefault(); INPUT.aim=true; toggleAim(true);},{passive:false});
  aimBtn.addEventListener('touchend',   e=>{e.preventDefault(); INPUT.aim=false; toggleAim(false);},{passive:false});

  const jmpBtn = document.getElementById('btnJump');
  jmpBtn.addEventListener('touchstart', e=>{e.preventDefault(); doJump();},{passive:false});

  const crchBtn = document.getElementById('btnCrouch');
  crchBtn.addEventListener('touchstart', e=>{e.preventDefault(); INPUT.crouch=!INPUT.crouch; updateCrouch();},{passive:false});

  const spBtn = document.getElementById('btnSprint');
  spBtn.addEventListener('touchstart', e=>{e.preventDefault(); INPUT.sprint=true;},{passive:false});
  spBtn.addEventListener('touchend',   e=>{e.preventDefault(); INPUT.sprint=false;},{passive:false});

  const relBtn = document.getElementById('btnReload');
  relBtn.addEventListener('touchstart', e=>{e.preventDefault(); doReload();},{passive:false});

  // Desktop fallback (keyboard + mouse)
  document.addEventListener('keydown', e => {
    if(e.code==='KeyW'||e.code==='ArrowUp')    JOY.dy=-1;
    if(e.code==='KeyS'||e.code==='ArrowDown')  JOY.dy=1;
    if(e.code==='KeyA'||e.code==='ArrowLeft')  JOY.dx=-1;
    if(e.code==='KeyD'||e.code==='ArrowRight') JOY.dx=1;
    if(e.code==='Space') doJump();
    if(e.code==='ShiftLeft') { INPUT.sprint=true; }
    if(e.code==='ControlLeft') { INPUT.crouch=!INPUT.crouch; updateCrouch(); }
    if(e.code==='KeyR') doReload();
    if(e.code==='KeyF') INPUT.fire=true;
    if(e.code==='KeyQ') { INPUT.aim=!INPUT.aim; toggleAim(INPUT.aim); }
  });
  document.addEventListener('keyup', e => {
    if(e.code==='KeyW'||e.code==='ArrowUp'||e.code==='KeyS'||e.code==='ArrowDown') JOY.dy=0;
    if(e.code==='KeyA'||e.code==='ArrowLeft'||e.code==='KeyD'||e.code==='ArrowRight') JOY.dx=0;
    if(e.code==='ShiftLeft') INPUT.sprint=false;
    if(e.code==='KeyF') INPUT.fire=false;
  });
  // Mouse look (desktop)
  let mouseDown=false;
  document.getElementById('gameCanvas').addEventListener('click', ()=>{ document.getElementById('gameCanvas').requestPointerLock&&document.getElementById('gameCanvas').requestPointerLock(); });
  document.addEventListener('mousemove', e => {
    if(document.pointerLockElement===document.getElementById('gameCanvas')){
      const s = GS.isAiming?0.0015:0.003;
      CAM.yaw   -= e.movementX*s;
      CAM.pitch -= e.movementY*s;
      CAM.pitch  = Math.max(-Math.PI/3,Math.min(Math.PI/3,CAM.pitch));
    }
  });
  document.addEventListener('mousedown', e=>{ if(e.button===0) INPUT.fire=true; if(e.button===2){INPUT.aim=true;toggleAim(true);} });
  document.addEventListener('mouseup',   e=>{ if(e.button===0) INPUT.fire=false; if(e.button===2){INPUT.aim=false;toggleAim(false);} });
  document.addEventListener('contextmenu', e=>e.preventDefault());
}

function toggleAim(on) {
  GS.isAiming = on;
  DOM.aimOverlay.classList.toggle('active', on);
  // FOV
  const targetFOV = on ? 45 : 75;
  camera.fov = targetFOV;
  camera.updateProjectionMatrix();
}

function doJump() {
  if (!PL.onGround || GS.isCrouching) return;
  PL.vel.y = PL.jumpForce;
  PL.onGround = false;
}

function updateCrouch() {
  GS.isCrouching = INPUT.crouch;
}

function doReload() {
  if (GS.reloading || GS.ammo === GS.maxAmmo || GS.reserve === 0) return;
  GS.reloading = true;
  GS.reloadTimer = 1.8;
  addKillFeed('ğŸ”„ Reloading...');
  if(isConnected) socket.emit('fps_reload');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SHOOTING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastFire = false;
function handleShooting(dt) {
  GS.shotCooldown = Math.max(0, GS.shotCooldown - dt);

  if (GS.reloading) {
    GS.reloadTimer -= dt;
    if (GS.reloadTimer <= 0) {
      const need = GS.maxAmmo - GS.ammo;
      const take = Math.min(need, GS.reserve);
      GS.ammo += take; GS.reserve -= take;
      GS.reloading = false;
    }
    return;
  }

  // Auto-spray: fires continuously while button is held
  lastFire = INPUT.fire;
  if (!INPUT.fire || GS.shotCooldown > 0) return;

  if (GS.ammo <= 0) { doReload(); return; }

  GS.ammo--;
  GS.shotCooldown = 0.18; // faster for spray

  // Muzzle flash
  if (gunMesh) {
    gunMesh.position.z += 0.04;
    setTimeout(()=>{ if(gunMesh) gunMesh.position.z -= 0.04; }, 60);
  }

  // Raycast
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

  if(isMultiplayer && opponentMesh && opponentMesh.visible) {
    // Multiplayer: shoot at opponent
    const headHit = raycaster.intersectObject(opponentMesh.userData.headHB);
    const bodyHit = raycaster.intersectObject(opponentMesh.userData.bodyHB);
    if(headHit.length>0 || bodyHit.length>0){
      const isHead = headHit.length>0 && (bodyHit.length===0 || headHit[0].distance<bodyHit[0].distance);
      sendShot(isHead ? 'head' : 'body');
    } else {
      sendShot(null);
    }
  } else {
    // Solo bot mode
    const headHit = raycaster.intersectObject(enemyHeadHB);
    const bodyHit = raycaster.intersectObject(enemyBodyHB);
    if (headHit.length > 0 || bodyHit.length > 0) {
      let dmg, isHead = false;
      if (headHit.length > 0 && (bodyHit.length === 0 || headHit[0].distance < bodyHit[0].distance)) {
        dmg = 85; isHead = true;
      } else {
        dmg = 24;
      }
      dealDamageToBot(dmg, isHead);
      showHitMarker(isHead);
    }
  }

  updateAmmoUI();
}

function dealDamageToBot(dmg, isHead) {
  if (GS.roundOver) return;
  GS.botHP = Math.max(0, GS.botHP - dmg);
  updateHealthUI();
  if (isHead) addKillFeed(`ğŸ¯ HEADSHOT! -${dmg}`);
  if (GS.botHP <= 0) endRound('player');
}

function dealDamageToPlayer(dmg) {
  if (GS.roundOver) return;
  GS.playerHP = Math.max(0, GS.playerHP - dmg);
  updateHealthUI();
  // Flash
  DOM.flash.classList.add('show');
  setTimeout(()=>DOM.flash.classList.remove('show'), 120);
  if (GS.playerHP <= 0) endRound('bot');
}

function showHitMarker(isHead) {
  DOM.hitMarker.classList.add('show');
  DOM.hitMarker.querySelector('svg').style.stroke = isHead ? '#ef4444' : '#f59e0b';
  setTimeout(()=>DOM.hitMarker.classList.remove('show'), isHead?250:150);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BOT AI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateBot(dt) {
  if (GS.roundOver || GS.gameOver) return;

  const botPos = enemy.position;
  const pPos = player.position;
  const dx = pPos.x - botPos.x;
  const dz = pPos.z - botPos.z;
  const dist = Math.sqrt(dx*dx+dz*dz);

  // Check line of sight (simple distance check)
  BOT.seePlayer = dist < 30;

  // â”€â”€ Roaming
  BOT.roamTimer -= dt;
  if (BOT.roamTimer <= 0 || dist < 2) {
    BOT.roamTimer = 2 + Math.random()*2;
    if (BOT.seePlayer && dist > 5) {
      // Move toward player
      BOT.roamTarget.set(pPos.x + (Math.random()-0.5)*4, 0, pPos.z + (Math.random()-0.5)*4);
    } else {
      // Random wander
      BOT.wanderAngle += (Math.random()-0.5)*Math.PI;
      BOT.roamTarget.set(botPos.x+Math.cos(BOT.wanderAngle)*8, 0, botPos.z+Math.sin(BOT.wanderAngle)*8);
      BOT.roamTarget.x = Math.max(-25,Math.min(25,BOT.roamTarget.x));
      BOT.roamTarget.z = Math.max(-25,Math.min(25,BOT.roamTarget.z));
    }
  }

  // Move toward roam target
  const tdx = BOT.roamTarget.x - botPos.x;
  const tdz = BOT.roamTarget.z - botPos.z;
  const tlen = Math.sqrt(tdx*tdx+tdz*tdz);
  if (tlen > 0.5) {
    const speed = BOT.seePlayer ? 2.5 : 2.0;
    const moveX = (tdx/tlen)*speed*dt;
    const moveZ = (tdz/tlen)*speed*dt;
    const np = new THREE.Vector3(botPos.x+moveX, botPos.y, botPos.z+moveZ);
    if(!checkObstacleCollision(np, 0.4)) {
      botPos.x += moveX; botPos.z += moveZ;
    }
  }

  // Turn to face player if seen
  if (BOT.seePlayer) {
    const targetAngle = Math.atan2(dx, dz);
    let dAngle = targetAngle - enemy.rotation.y;
    while(dAngle > Math.PI) dAngle -= Math.PI*2;
    while(dAngle < -Math.PI) dAngle += Math.PI*2;
    enemy.rotation.y += dAngle * BOT.turnSpeed * dt;
  } else {
    enemy.rotation.y += 0.5*dt;
  }

  // Leg animation
  const t = performance.now()*0.004;
  if (enemyGroup.children[5]) enemyGroup.children[5].rotation.x = Math.sin(t)*0.4; // legL
  if (enemyGroup.children[6]) enemyGroup.children[6].rotation.x = Math.sin(t+Math.PI)*0.4; // legR

  // â”€â”€ Shoot at player
  BOT.shotTimer -= dt;
  if (BOT.seePlayer && dist < 25 && BOT.shotTimer <= 0) {
    BOT.shotTimer = BOT.shotInterval + Math.random()*1.5; // noob: slow fire rate
    const hitChance = Math.max(0.08, 0.35 - dist*0.008); // low accuracy
    if (Math.random() < hitChance) {
      const headChance = 0.05; // very low headshot from noob
      const isHead = Math.random() < headChance;
      dealDamageToPlayer(isHead ? 60 : 12);
    }
    // Visual indicator: flash the gun momentarily
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PLAYER MOVEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updatePlayer(dt) {
  if (GS.roundOver || GS.gameOver) return;

  // Sprint stamina
  if (INPUT.sprint && (JOY.dx !== 0 || JOY.dy !== 0) && GS.sprintStamina > 0) {
    GS.isSprinting = true;
    GS.sprintStamina = Math.max(0, GS.sprintStamina - dt*25);
  } else {
    GS.isSprinting = false;
    GS.sprintStamina = Math.min(100, GS.sprintStamina + dt*15);
  }
  DOM.sprintFill.style.width = GS.sprintStamina+'%';

  // Determine speed
  let speed = PL.walkSpeed;
  if (GS.isSprinting && GS.sprintStamina > 0) speed = PL.sprintSpeed;
  if (GS.isCrouching) speed = PL.crouchSpeed;

  // Camera height
  const targetH = GS.isCrouching ? PL.crouchHeight : PL.height;
  camera.position.y += (targetH - camera.position.y) * 8 * dt;

  // Move direction from joystick + camera yaw
  const forward = new THREE.Vector3(-Math.sin(CAM.yaw), 0, -Math.cos(CAM.yaw));
  const right   = new THREE.Vector3(Math.cos(CAM.yaw), 0, -Math.sin(CAM.yaw));

  const moveVec = new THREE.Vector3();
  moveVec.addScaledVector(forward, -JOY.dy);
  moveVec.addScaledVector(right, JOY.dx);
  if (moveVec.length() > 0) moveVec.normalize();

  // Apply movement with obstacle check
  const nx = player.position.x + moveVec.x * speed * dt;
  const nz = player.position.z + moveVec.z * speed * dt;
  const testPos = new THREE.Vector3(nx, player.position.y, player.position.z);
  if (!checkObstacleCollision(testPos, 0.35)) player.position.x = nx;
  const testPosZ = new THREE.Vector3(player.position.x, player.position.y, nz);
  if (!checkObstacleCollision(testPosZ, 0.35)) player.position.z = nz;

  // Arena bounds
  player.position.x = Math.max(-27, Math.min(27, player.position.x));
  player.position.z = Math.max(-27, Math.min(27, player.position.z));

  // Gravity
  PL.vel.y += PL.gravity * dt;
  player.position.y += PL.vel.y * dt;
  if (player.position.y <= 0) {
    player.position.y = 0;
    PL.vel.y = 0;
    PL.onGround = true;
  }

  // Apply camera rotation
  player.rotation.y = CAM.yaw;
  camera.rotation.x = CAM.pitch;

  // Head bob
  if ((JOY.dx!==0||JOY.dy!==0) && PL.onGround) {
    const bobAmt = GS.isCrouching ? 0.02 : (GS.isSprinting ? 0.07 : 0.04);
    const bobSpeed = GS.isSprinting ? 12 : 8;
    const bob = Math.sin(performance.now()*0.001*bobSpeed)*bobAmt;
    camera.position.y += bob;
    if(gunMesh) gunMesh.position.y = -0.14 + Math.sin(performance.now()*0.001*bobSpeed*1.2)*0.01;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  COLLISION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkObstacleCollision(pos, radius) {
  for (const o of obstacles) {
    if (pos.x+radius > o.minX && pos.x-radius < o.maxX &&
        pos.z+radius > o.minZ && pos.z-radius < o.maxZ &&
        pos.y+PL.height > o.minY && pos.y < o.maxY) {
      return true;
    }
  }
  return false;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ROUND MANAGEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function endRound(winner) {
  if (GS.roundOver) return;
  GS.roundOver = true;

  if (winner === 'player') {
    GS.playerScore++;
    showStatus('YOU WIN!', 'Round ' + GS.round, '#4ade80');
    addKillFeed('ğŸ† You eliminated the bot!');
  } else {
    GS.botScore++;
    showStatus('YOU DIED', 'Round ' + GS.round, '#ef4444');
    addKillFeed('ğŸ’€ Bot eliminated you!');
  }

  updateRoundUI();

  setTimeout(() => {
    hideStatus();
    if (GS.round >= GS.maxRounds) {
      endGame();
    } else {
      GS.round++;
      nextRound();
    }
  }, 2500);
}

function nextRound() {
  GS.roundOver = false;
  GS.playerHP = GS.maxHP;
  GS.botHP    = GS.maxHP;
  GS.ammo     = GS.maxAmmo;
  GS.reloading= false;
  GS.shotCooldown = 0;

  // Respawn
  player.position.set(0, 0, -18);
  camera.position.y = PL.height;
  PL.vel.set(0,0,0);

  resetBot();
  updateHealthUI();
  updateAmmoUI();
  updateRoundUI();
}

function endGame() {
  GS.gameOver = true;
  const won = GS.playerScore > GS.botScore;
  const screen = document.getElementById('endScreen');
  document.getElementById('esResult').textContent = won ? 'ğŸ† VICTORY!' : 'ğŸ’€ DEFEAT';
  document.getElementById('esResult').style.color  = won ? '#4ade80' : '#ef4444';
  document.getElementById('esScore').textContent   = `${GS.playerScore} â€“ ${GS.botScore}`;
  screen.style.display = 'flex';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  UI UPDATES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHealthUI() {
  DOM.phFill.style.width = (GS.playerHP/GS.maxHP*100)+'%';
  DOM.ehFill.style.width = (GS.botHP/GS.maxHP*100)+'%';
  DOM.phFill.style.background = GS.playerHP > 50 ? 'linear-gradient(90deg,#22c55e,#4ade80)' :
    GS.playerHP > 25 ? 'linear-gradient(90deg,#f59e0b,#fbbf24)' : 'linear-gradient(90deg,#ef4444,#f87171)';
}

function updateAmmoUI() {
  DOM.ammoNum.textContent = GS.ammo+'/'+GS.reserve;
  DOM.ammoNum.style.color = GS.ammo === 0 ? '#ef4444' : GS.ammo <= 2 ? '#f59e0b' : '#fff';
}

function updateRoundUI() {
  DOM.roundNum.textContent = 'ROUND '+GS.round+'/'+GS.maxRounds;
  DOM.scoreDisp.textContent = 'YOU '+GS.playerScore+' â€“ '+GS.botScore+' BOT';
}

function showStatus(main, sub, color) {
  DOM.statusMain.textContent = main;
  DOM.statusMain.style.color = color;
  DOM.statusSub.textContent  = sub;
  DOM.statusText.classList.add('show');
}
function hideStatus() { DOM.statusText.classList.remove('show'); }

function addKillFeed(msg) {
  const el = document.createElement('div');
  el.className = 'kf-item';
  el.textContent = msg;
  DOM.killFeed.prepend(el);
  setTimeout(()=>el.remove(), 2100);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  MAIN LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function animate() {
  requestAnimationFrame(animate);
  if (!gameActive) return;

  const dt = Math.min(clock.getDelta(), 0.05);

  updatePlayer(dt);

  // Bot AI only if not in multiplayer
  if(!isMultiplayer) updateBot(dt);

  // Interpolate opponent position smoothly
  interpolateOpponent(dt);

  handleShooting(dt);

  // Send position to server
  sendPosition();

  // Reload timer display
  if (GS.reloading) updateAmmoUI();

  renderer.render(scene, camera);
// â”€â”€ Boot multiplayer socket on page load
initSocket();
</script>
</body>
</html>
